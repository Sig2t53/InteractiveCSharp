using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Test_Interface
{
    //インターフェースを用いる利点
    //  •ポリモーフィズムを実装するとき
    //  •多重継承の方法を取り入れたいとき
    //  •複数のシステムを疎結合して開発したいとき
    //  •複数のプロジェクトを並行に開発したいとき

    //インターフェースの主な制限
    //  •フィールド、コンストラクタ、デストラクタは定義できない。
    //  •自分でアクセス修飾子を付けられない
    //   (暗黙のうちにアクセス修飾子が決まっている)
    //  •定義の中に、クラス、インターフェイス、列挙体、構造体のような型の定義をネストして持つことができない
    //   例.↓の定義だとエラー「'IMyInterface.A': インターフェイスは型を宣言できません。」が発生する
    //      interface IMyInterface
    //      {
    //          void Show();
    //          class A { }
    //      }
    //  ・継承できるのはインターフェースだけ(クラス、構造体は継承できない)
    //    例.↓だとコンパイルエラー「インターフェイス リストの型 'A' はインターフェイスではありません。」が発生する
    //      class A { }
    //      interface IB : A { }

    //抽象クラスとインターフェースの違い
    // 抽象クラス
    //   - 実装したメソッドを持つことができる
    //     ※全て実装/部分的に実装のどちらも可能
    //   - 抽象クラスもしくは通常のクラスから1 つだけを親クラスとして持つことが可能
    //     インターフェースを継承することも可能(複数でもOK)
    //   - 抽象クラスはメソッドをpublicだけでなく、private やprotectedなどに変更可能
    //   - フィールドが持てる
    //       メソッドの場合と同様にstatic/非static,privateやprotectedなどの
    //       様々な修飾子が設定可能
    //
    // インターフェイス
    //   - 抽象メソッドしか持てない
    //       インターフェイスは、「あれをします」「これをします」という原則を告げるものだから
    //   - インターフェイスしか継承できないが複数継承することが可能
    //   - メソッドは既定でpublic
    //   - フィールドが持てない

    // 抽象クラスとインターフェースどちらを使うかの判断
    //   下記URLも参照
    //   https://stackoverflow.com/questions/20193091/recommendations-for-abstract-classes-vs-interfaces
    //
    //   抽象クラスを使ったほうがよい場面
    //     - プログラムの中心もしくは前提となる動作を記述する場合
    //         抽象クラスの段階で実装しておいたメソッドは、すべての子クラスでそのまま使えるため
    //     - 新しいメソッドの追加が発生する場合
    //         抽象クラスに新しいメソッドを追加するときに、最初から実装した形にしておけば、
    //         すでに継承した子クラスを含む既存のコードも問題なく実行可能
    //     - 部分的に異なるプログラムを複数作成する計画がある場合
    //         基本クラス1つを更新すれば、すべての継承クラスがそれに合わせて自動的に更新されるため、プログラムのバージョン管理が簡単になる
    //     - 実装したものすべてに、共通の具体的な機能をもたせたい場合
    //         クラスを部分的に実装可能なため
    //     - 大規模な機能を1 単位として設計する場合
    //
    //  インターフェイスを使ったほうがよい場面
    //     - 動作を最初から書いていきたい場合
    //        インターフェイスにおけるメソッドの定義 = 実装するクラスで何をすることになっているかの原則・契約のようなもの
    //        メソッドは自分で最初から実装する必要があるが、逆に言えばどのように実装してもいいということ
    //     - 多重継承のようなことを表現したい場合
    //     - 変更がない場合
    //         インターフェイスに新しいメソッドを追加する必要が生じたときに、
    //         どこで実装されているかをすべて洗い出して、それぞれの個所に具体的な実装を書く必要があるため
    //         ※バージョンアップなどでインターフェイスを変更するのであれば、
    //           別のインターフェイスとして、新しく作ったほうがよい。
    //     - 実現しようとする機能が、あまり密接に関係しない、さまざまなオブジェクトで使えそうな場合は、
    //         関連のないクラスに共通の機能を提供するのに最適なため
    //     - ある機能の小さな一部分を集中して設計する場合

    //インターフェースのメソッドにはabstractは指定できない
    //↓は「修飾子 'abstract' がこの項目に対して有効ではありません。」が発生する
    //interface IMyInterface
    //{
    //    abstract void Show();
    //}

    //↓はコンパイルエラー「インターフェイスにフィールドを含めることはできません。」が発生する
    //interface IAttributeInterface
    //{
    //    int i;
    //}
    //抽象クラスならOK
    abstract class MyAttributeClass
    {
        public static int i = 10;
        internal int j = 45;
    }

    //タグ（タギングもしくはマーカー）インターフェイス
    //  - 空のインターフェイスのこと
    //  - 共通の親を作成できる点が利点
    //  - マーカーインターフェイスはメソッドを1つも含まないので、
    //    追加のメソッドを新たに実装することなく、インターフェイスの暗黙的な変換だけを利用可能
    //  - マーカーインターフェイスと拡張メソッドを用いると、
    //    さまざまなプログラムの課題に対処できる場面がある
    //    ※MSDNではマーカーインターフェースの代わりに属性を使うことを推奨している
    //
    //マーカーインターフェイスの例
    interface IMarkerInterface
    {
    }

    //↓はコンパイルエラー「修飾子 'sealed' がこの項目に対して有効ではありません。」が発生する
    //sealed interface IMyInterface
    //{
    //    void Show();
    //}

    class Program
    {
        static void Main(string[] args)
        {
        }
    }
}
